NSI-RI lifetime management web service
======================================

This repository contains a small, self-contained web service which:
	- handles REST calls
	- instantiates, configures, starts, stop NSI-RI instances, feeding
	  them an XML test scenario
	- keeps track of their lifetime during test progression, and collects
	  final test reports at the end


Starting the service (with Maven)
---------------------------------

	mvn spring-boot:run


Deployment
----------

	mvn package

	just copy the target/nsi-ri-restrunner-?.?.?-SNAPSHOT.jar fatjar file
	anywhere. It is self-contained.

	run with:

	java -jar si-ri-restrunner-?.?.?-SNAPSHOT.jar


Changing the REST listen HTTP port
----------------------------------

create an "application.properties" file in the current directory (where the
service is being run), with the following line:

	server.port = NNNN

(Keep NNNN over 1024 to allow it being run as non-root)


Database management
-------------------

The REST service comes with a HSQL database built-in which is used to
temporarily store all the metadata of the NSI-RI instanced launched and
terminated in the past. This database, normally, is wiped clean and recreated
at every launch of the web service, erasing all previous history.

In case the history of the runs is to be preserved across multiple stop and 
restart cycles of the REST web service, create (or edit) an
"application.properties" file in the local directory, adding this line:

spring.jpa.hibernate.ddl-auto=update



Providing an NSI-RI template package
------------------------------------

The web service implementation starts and manages NSI-RI instances by
allocating them dynamically. Each time an NSI-RI run is requested,
an NSI-RI engine is copied over a temporary directory and run from there.
The NSI-RI serving as the template for instantiation of other instances
is to be provided to the REST web service engine whilst contained in a zip
file. The engine normally checks for the existance of the file

  ../nsi-ri/nsi.zip

This can be overridden via a local "application.properties" file, adding the
line:
nsi-ri-runner.zipFilePath=path/to/nsi.zip

The ZIP file shall contain a recursive archivial of a complete (able to run)
NSI-RI instance. The "startConsole.sh" script is run.


Start request
-------------


JSON data to be POSTed to the base url "/job":

	{
		"requesterId": "your_name",
		"xmlData": "...xml data..."
	}


Returned value:

	{
		"id": "...some UUID...",
		"status": "QUEUED/STARTED/ABORTED_ERROR/COMPLETED_OK/COMPLETED_ERROR",
		"error": null
	}

Notes: the "id" bit is an uuid value which can be used by the requester to
track the execution of the tasked job. It is generated by the REST web service
engine upon instantiation of a new job, and never reused.

The significance of the status string is:
	- QUEUED - job accepted and put in the execution queue, but not yet
	  processed;
	- STARTED - an NSI-RI has been instantiated and possibly started, but
	  the test scenario execution has yet to complete;
	- ABORTED_ERROR - a major error (due to configuration or other
	  conflict) has occurred. This should normally not happen;
	- COMPLETED_OK - the test scenario execution has completed, the test
	  went through all it stages successfully. The NSI-RI instance is no
	  longer alive and its resources have been collected. A test report
	  XML is available for retrieval.
	- COMPLETED_ERROR - the test scenario execution has completed, the test
	  did not go through all it stages due to unexpected error. 
	  The NSI-RI instance is no longer alive and its resources have been 
	  collected. A test report XML is available for retrieval.


Job execution status poll
-------------------------

JSON GET request to the url "/job/{jobID}" will result in:

	{
		"id": "{jobId}",
		"status": "..see note..",
		"testReport": "..see note.."
	}

Note: the "status" string meaning is the same as above (see the job start
request). Plus, it can also be "NOT_FOUND" in case the specified jobId does
not match any known job instance.

The "testReport" string contains the XML data of the output test report from
the NSI-RI. This string will be populated only after the "status" reaches
COMPLETED_OK or COMPLETED_ERROR.


